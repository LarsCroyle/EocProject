# Darkheart
Generated by [Rojo](https://github.com/rojo-rbx/rojo) 7.3.0.

## Darkheart Github Page

Some Documentation and extra information about the code itself:

## Entity Component System
This codebase is running an ECS (Entity Component System) Framework

This essentially means that all data is described as identifiers with data packages on them (Entities and components respectively), while all behavior is described as a System that acts on a stream of specific Entities.

Take for example, the way I would represent the human heart in this framework:

"Human Entity" has a "Heart" Component storing pieces of data: "Level of Oxygenated blood" and "Level of unoxygenated blood"
The "BloodPumpSystem" will then take the "unoxygenated blood" data and turn it into "oxygenated blood" for every entity with a "Heart", each frame.

That is a contrived example but it is how this framework fundamentally operates on any example. All code follows a similar structure and principle of this example.

## The information on the Backend

There are dozens of Systems working on both the Client and Server side of this project, each one trying to squeeze in it's workload and all be crammed with each other system into a frame's worth of work.
This limit has spilled over and it is now unreliable to assume that an Entity can be chained between Systems with varying priorities in a single frame. The preferred method for the so-called "cleanup and chain" pattern used in
the combat systems is instead to have:

ChainIdentifier Components (For example, the "Stun" component on an attackentity)
ChainMarker Components (For example, a "StunSuccessful" component)

The StunSystem's Tag will then be like:

```lua
{
    ...,
    "Stun",
    "!StunSuccessful", -- because we don't want an attackentity whose stun is already processed, we can't rely on the attackentity existing for only 1 frame as combat chain takes more than 1 frame to perform.
}
```

### ActionHandler

The ActionHandlerSystem is the singlehandedly most important system hands down in this backend.
It handles the conversion of all Actions into Sequences, thereby making all Attacks possible in the game and allowing for a versatile system that allows items to function as well.

Sequences are another important aspect of this backend, we use them to define how moves work.

An example of a Sequence in code looks like this:

```lua
local Sequence = require(game.ServerStorage.Modules.Classes.Sequence)

local MySequence = Sequence.new({
    Name = "WhateverNameYouWant",
    Speed = 1, -- 0 = stopped, scales up to infinity technically and will run faster
    Frames = { -- here is where the important stuff is
        {0, "PlaySound", "SoundName"}, -- plays the given sound at frame 0 with the Action's UserEntity as a preset
        {5, 17, "Attack", "..."}, -- uses the second arg after Attack as an identifer for an attack table in the AttackInformation. the "5, 17" here means it will run the attack for all frames between 5 and 17
        {25, 100, 5, "Attack", "..."} -- every 5 frames between the 25th and 100th frame after playing the Sequence, runs the supplied attack
    }
})

MySequence:Play()

while MySequence:IsPlaying() do
    task.wait()
end

-- and thats the basics of how sequences work. i wrote the module myself.
```

## Libraries
Some of the code I have here is open sourced tools.
The open sourced tools include:

Trove v0.5.0 -- a class used for cleaning up code more efficiently
Signal v1.4.1 -- a class that uses the observer design pattern to handle events and connections
Promise v4.0.0 -- a class that handles errors and async operations more fluently
sleitnick Loader v2.0.0 -- a function library for operating on tables and modulescripts more easily
sleitnick Net v0.1.0 -- a function library for scripting in networking
sleitnick TableUtil v1.2.0 -- a function library for dealing with tables more efficiently

and finally
Fusion v0.2 -- a UI library
